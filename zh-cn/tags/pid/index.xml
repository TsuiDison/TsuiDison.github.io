<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PID on Tsui</title>
    <link>https://TsuiDison.github.io/zh-cn/tags/pid/</link>
    <description>Recent content in PID on Tsui</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 19 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://TsuiDison.github.io/zh-cn/tags/pid/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PID开环测试</title>
      <link>https://TsuiDison.github.io/zh-cn/posts/pid%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Wed, 19 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://TsuiDison.github.io/zh-cn/posts/pid%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;位置式pid定速控制&#34;&gt;&#xD;&#xA;  位置式PID定速控制&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%bd%8d%e7%bd%ae%e5%bc%8fpid%e5%ae%9a%e9%80%9f%e6%8e%a7%e5%88%b6&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;测试闭环的缺点0&#34;&gt;&#xD;&#xA;  测试闭环的缺点0&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%b5%8b%e8%af%95%e9%97%ad%e7%8e%af%e7%9a%84%e7%bc%ba%e7%82%b90&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;使用电机驱动的测试程序，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;显示电机给的驱动力&lt;/li&gt;&#xA;&lt;li&gt;显示由编码器测量得到的实际速度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;显然，当我们给转盘阻力的时候转盘会变慢，这也就是闭环的缺点了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;编码器设置&#34;&gt;&#xD;&#xA;  编码器设置&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e7%bc%96%e7%a0%81%e5%99%a8%e8%ae%be%e7%bd%ae&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;测速的代码是这样的&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;40&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Speed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Encoder_Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这意味着每计数40转就测一次速，根据平均速度测量的一些经验我们知道&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;测量周期越长，测到的速度就越精确(在被测速度接近于匀速的情况下)&lt;/li&gt;&#xA;&lt;li&gt;但是刷新周期也会越长&#xA;因此合理选择测速周期也是一个博弈。在之后引入PID后一般会将其设置为与PID的调控周期保持一致。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;引入pid&#34;&gt;&#xD;&#xA;  引入PID&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%bc%95%e5%85%a5pid&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要将主程序中所有的PWM设值部分改成target，表示期望值，至于后面怎么样调PWM是PID要干的事情，&lt;/li&gt;&#xA;&lt;li&gt;按照公式写代码，核心代码如下&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Error1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Error0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Actual&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ErrorInt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*PID计算*/&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Kp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ki&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ErrorInt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Kd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*输出限幅*/&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;Motor_SetPWM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;pi&#34;&gt;&#xD;&#xA;  PI&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#pi&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一开始先不考虑微分项$K_d$，令其为零，开始测试。&lt;/li&gt;&#xA;&lt;li&gt;测试正常进行，&lt;/li&gt;&#xA;&lt;li&gt;不过笔者发现一个bug：在高速的时候看不清不了解，看到定速效果良好，但是在0速度的定速的时候这个程序不仅能定速，还能定位。也就是说在定速为零的时候如果强行扭动转台，转台不仅会施加阻力抵挡，还会在最后回归原始位置。&lt;/li&gt;&#xA;&lt;li&gt;再看代码时发现，强行扭动一定距离产生的error会积累out，最后即使速度为零了，这些out也没有消散，还是要往回抵消，因此也就产生了定位的效果。&lt;/li&gt;&#xA;&lt;li&gt;如果我们去掉积分项目，也容易验证到之前理论部分所展示的动态平衡，也就是实际值始终低于预期值，且差为常数&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>PID代码学习:程序移植</title>
      <link>https://TsuiDison.github.io/zh-cn/posts/pid%E7%A7%BB%E6%A4%8D%E7%A1%AC%E4%BB%B6%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 13 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://TsuiDison.github.io/zh-cn/posts/pid%E7%A7%BB%E6%A4%8D%E7%A1%AC%E4%BB%B6%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;h1 id=&#34;一些对软件的个性化设置&#34;&gt;&#xD;&#xA;  一些对软件的个性化设置&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%b8%80%e4%ba%9b%e5%af%b9%e8%bd%af%e4%bb%b6%e7%9a%84%e4%b8%aa%e6%80%a7%e5%8c%96%e8%ae%be%e7%bd%ae&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;与vscode的联动&#34;&gt;&#xD;&#xA;  与vscode的联动&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%b8%8evscode%e7%9a%84%e8%81%94%e5%8a%a8&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;笔者的vscode有内联ai，又怎么肯在$\mu$Vision中老实跟着他打代码呢，但是在编译的时候又需要借助工程，于是参考&lt;a href=&#34;https://blog.csdn.net/weixin_45295367/article/details/125395692&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;某博客&lt;/a&gt;,在设置中添加了自动reload外部编译器修改的设置。&lt;/p&gt;&#xA;&lt;h2 id=&#34;繁琐步骤的精简&#34;&gt;&#xD;&#xA;  繁琐步骤的精简&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e7%b9%81%e7%90%90%e6%ad%a5%e9%aa%a4%e7%9a%84%e7%b2%be%e7%ae%80&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;江协貌似每一次都要在软件里删，实际里删，然后再实际中添加，再在软件中添加。我觉得直接覆盖一遍的效果与这四部的效果是一样的&lt;/p&gt;&#xA;&lt;h1 id=&#34;前期代码移植&#34;&gt;&#xD;&#xA;  前期代码移植&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%89%8d%e6%9c%9f%e4%bb%a3%e7%a0%81%e7%a7%bb%e6%a4%8d&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;移植的OLED与LED都是属于hardware。&lt;/p&gt;&#xA;&lt;h2 id=&#34;oled&#34;&gt;&#xD;&#xA;  OLED&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#oled&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;根据视频指引，添加了更强的OLED支持工具，可以输出一些中文字符、浮点数等，&lt;/p&gt;&#xA;&lt;h2 id=&#34;led&#34;&gt;&#xD;&#xA;  LED&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#led&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;需要修改一些名称，按照&lt;a href=&#34;https://www.bilibili.com/video/BV1G9zdYQEr3/?p=4&amp;amp;spm_id_from=333.1387.top_right_bar_window_history.content.click&amp;amp;vd_source=eca564ad7b44345c8105eebb08f088c6&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;视频操作&lt;/a&gt;，可以归纳为以下几个点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;修改&lt;code&gt;LED.c&lt;/code&gt;文件里面的定义，将LED1全部改成LED，接口改Pin_13,删去所有关于LED2的函数&lt;/li&gt;&#xA;&lt;li&gt;将&lt;code&gt;LED.h&lt;/code&gt;文件中的LED1与LED2作相应的修改(换名与删除)&lt;/li&gt;&#xA;&lt;li&gt;在主文件&lt;code&gt;main.c&lt;/code&gt;中编写测试代码，&lt;/li&gt;&#xA;&lt;li&gt;运行，拷入，没有问题证明移植成功。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;按键key&#34;&gt;&#xD;&#xA;  按键key&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%8c%89%e9%94%aekey&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;移植定时器从而实现非阻塞式&#34;&gt;&#xD;&#xA;  移植定时器(从而实现非阻塞式)&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e7%a7%bb%e6%a4%8d%e5%ae%9a%e6%97%b6%e5%99%a8%e4%bb%8e%e8%80%8c%e5%ae%9e%e7%8e%b0%e9%9d%9e%e9%98%bb%e5%a1%9e%e5%bc%8f&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在system中移植定时器&lt;/li&gt;&#xA;&lt;li&gt;修改TIM2为TIM1(因为TIM2另有用途)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;注意这里后面改TIM1，但是前面改PB1为PB2&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于高级定时器TIM2_IRQn需要查阅其定义使用更新型定时器移植过来(具体原理不懂)&lt;/li&gt;&#xA;&lt;li&gt;下面的测试函数则需要在Start中找结果&lt;/li&gt;&#xA;&lt;li&gt;测试，在main.c函数中同理编写即可&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;key&#34;&gt;&#xD;&#xA;  key&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#key&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首先需要改pin，这里根据他的解释我终于知道改数字的依据是什么了：见视频17:30时候对引脚电路的描述，本质上是为了引脚之间关系要对得上，比如K1与K2按键对应的事stm32的pin10和pin11，因此就要将阿健进行相应的修改。&lt;/li&gt;&#xA;&lt;li&gt;完成所有修改之后就可以进行测试了，编写一个简单的if语句即可。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;旋钮&#34;&gt;&#xD;&#xA;  旋钮&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%97%8b%e9%92%ae&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;这一个步骤需要用到模数转换，因此将stm32教程的模数转换部分移植过来，(之后更名为RP)&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在这里我有点清楚hardware和system的区别了，hardware都是外接的设备，比如按键、旋钮、LED等，而system应该是已有设备实现的一些功能，比如计数器。&lt;/p&gt;</description>
    </item>
    <item>
      <title>PID基础理论</title>
      <link>https://TsuiDison.github.io/zh-cn/posts/pid%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</link>
      <pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://TsuiDison.github.io/zh-cn/posts/pid%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</guid>
      <description>&lt;h1 id=&#34;连续形式&#34;&gt;&#xD;&#xA;  连续形式&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e8%bf%9e%e7%bb%ad%e5%bd%a2%e5%bc%8f&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;无需多言,公式就这么简单&#xA;$$&#xA;out(t)=K_p\left(e(t)+\frac{1}{T_i}\int_{0}^te(t)dt+T_d\frac{de(t)}{dt} \right)&#xA;$$&#xA;或者也可以写成三个系数的形式&#xA;$$&#xA;out(t)=K_pe(t)+K_i\frac{1}{T_i}\int_{0}^te(t)dt+K_d\frac{de(t)}{dt}&#xA;$$&#xA;下面从各个项解释一下&lt;/p&gt;&#xA;&lt;h2 id=&#34;比例项&#34;&gt;&#xD;&#xA;  比例项&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%af%94%e4%be%8b%e9%a1%b9&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;看看纯比例项的PID&#xA;$$&#xA;out(t)=K_pe(t)&#xA;$$&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以理解为信号与系统里面的无记忆(与过去无关)因果(与未来无关)系统，输出仅取决于当前时刻的误差&lt;/li&gt;&#xA;&lt;li&gt;$K_p$越大，系统响应越快，但是超调也会随之增加(严重的话会产生不可忽略的震荡)&lt;/li&gt;&#xA;&lt;li&gt;存在不可忽略的&lt;strong&gt;稳态误差&lt;/strong&gt;($K_p$越大稳态误差越小)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;稳态误差&lt;/strong&gt;可以理解为这一种“趋势”(比如摩擦力)与驱动力的动态平衡，比如&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在控速PID中显然会一直受到摩擦力的作用，使得最终控诉结果会小于预期值&lt;/li&gt;&#xA;&lt;li&gt;在锅炉控温时自然散热这种降温的“趋势”也造成了实控温度会变低&#xA;因此最后稳态误差偏向于“趋势”的方式&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;通过两张图片可以很好的理解稳态误差&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://TsuiDison.github.io/zh-cn/posts/pid%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/Kp.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;左边的是$K_p$较小的时候,右边是$K_p$较大的时候，&lt;/p&gt;&#xA;&lt;h1 id=&#34;积分项&#34;&gt;&#xD;&#xA;  积分项&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e7%a7%af%e5%88%86%e9%a1%b9&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;积分项还取决于历史时刻&lt;/li&gt;&#xA;&lt;li&gt;从理解上来看，也就是说只要有误差存在，积分项就会随时间一直增大，从而务必会使得误差为零才罢休，因此这也就很能弥补稳态误差了。&lt;/li&gt;&#xA;&lt;li&gt;$K_i$越大，积分项权重越大，稳态误差小时越快，但是也就有更强的滞后性(原理和$k_P$大的原因相同)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;微分项&#34;&gt;&#xD;&#xA;  微分项&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%be%ae%e5%88%86%e9%a1%b9&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;前面无论是纯比例项还是加上了积分项，在$K_p,K_i$很大的时候都会“冲”，即越过预期值，并可能在预期值附近反复震荡，恶性的话甚至会变成自激振荡，最后凭空产生误差。微分项的原理就是使得实际值在快被调回时减速，从而让实际值在接近目标值时稳定下来。&lt;/p&gt;&#xA;&lt;h1 id=&#34;离散形式&#34;&gt;&#xD;&#xA;  离散形式&#xD;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e7%a6%bb%e6%95%a3%e5%bd%a2%e5%bc%8f&#34;&gt;&#xD;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;链接到标题&#34;&gt;&lt;/i&gt;&#xD;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;链接到标题&lt;/span&gt;&#xD;&#xA;  &lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;……&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
